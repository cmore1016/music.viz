<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Music Visualizer</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:#0f1724;
    --accent:#36c;
    --muted:#98a0b3;
  }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
  body{background:linear-gradient(180deg,var(--bg),#061020);color:#eef;display:flex;align-items:center;justify-content:center;padding:18px}
  .app{width:100%;max-width:940px;border-radius:12px;padding:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:0 8px 30px rgba(0,0,0,0.6);}
  header{display:flex;align-items:center;gap:12px;margin-bottom:10px}
  header h1{font-size:18px;margin:0}
  .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:10px}
  .controls > *{background:var(--panel);padding:8px;border-radius:8px;display:flex;align-items:center;gap:8px}
  input[type="file"]{color:transparent}
  button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px 10px;border-radius:8px;cursor:pointer; user-select:none;}
  button:active{transform:translateY(1px)}
  canvas{width:100%;height:360px;border-radius:8px;display:block;background:linear-gradient(180deg,#02061a,rgba(255,255,255,0.01));box-shadow:inset 0 2px 12px rgba(255,255,255,0.02)}
  .sliders{display:flex;gap:10px;align-items:center}
  label{font-size:13px;color:var(--muted)}
  .small{font-size:13px;color:var(--muted)}
  @media (max-width:600px){canvas{height:260px}}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>Music Visualizer</h1>
    <div class="small">Load a song or mic → choose mode → play</div>
  </header>
  <div class="controls">
    <div><label class="small">Audio file</label><input id="file" type="file" accept="audio/*"></div>
    <div><label class="small">Mic</label><button id="micBtn">Use Microphone</button></div>
    <div><label class="small">Play / Pause</label><button id="playBtn">Play</button></div>
    <div class="sliders"><label class="small">Volume</label><input id="volume" type="range" min="0" max="1" step="0.01" value="0.9"></div>
    <div><label class="small">Bars</label><input id="bars" type="number" min="8" max="256" value="64" style="width:70px"></div>
    <div><label class="small">Bar Color</label><input id="barColor" type="color" value="#36c"></div>
    <div><label class="small">Wave Color</label><input id="waveColor" type="color" value="#7be"></div>
    <div>
      <label class="small">Visual Mode</label>
      <select id="mode">
        <option>Bars only</option>
        <option>Wave only</option>
        <option selected>Bars + Wave</option>
        <option>Circle Bars</option>
        <option>Circle Wave</option>
        <option>Circle Bars + Wave</option>
      </select>
    </div>
    <div>
      <button id="repeatBtn">Repeat: Off</button>
    </div>
    <div>
      <button id="randomizeBtn">Random Lines & Colors</button>
    </div>
  </div>
  <canvas id="canvas"></canvas>
</div>

<script>
(async function(){
  const fileInput = document.getElementById('file');
  const micBtn = document.getElementById('micBtn');
  const playBtn = document.getElementById('playBtn');
  const volumeControl = document.getElementById('volume');
  const barsInput = document.getElementById('bars');
  const barColorInput = document.getElementById('barColor');
  const waveColorInput = document.getElementById('waveColor');
  const modeSelect = document.getElementById('mode');
  const repeatBtn = document.getElementById('repeatBtn');
  const randomizeBtn = document.getElementById('randomizeBtn');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  function fitCanvas(){
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  let audioCtx = null, sourceNode = null, analyser = null, gainNode = null;
  let dataArray = null, waveformArray = null, rafId = null;
  let audioElement = new Audio(); audioElement.crossOrigin = "anonymous";
  let usingMic = false, micStream = null;

  // Repeat flag
  let isRepeat = false;

  // Random lines state
  let randomLinesActive = false;
  let randomLines = [];

  function ensureAudioContext(){
    if(!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      analyser.smoothingTimeConstant = 0.7;
      gainNode = audioCtx.createGain();
      gainNode.gain.value = parseFloat(volumeControl.value);
      analyser.connect(gainNode);
      gainNode.connect(audioCtx.destination);
    }
  }

  fileInput.addEventListener('change', e=>{
    if(!e.target.files || !e.target.files[0]) return;
    usingMic = false; stopMic();
    audioElement.src = URL.createObjectURL(e.target.files[0]);
    audioElement.loop = isRepeat;
    audioElement.load();
    setupMediaElementSource();
  });

  micBtn.addEventListener('click', async ()=>{
    if(usingMic){ stopMic(); micBtn.textContent = 'Use Microphone'; return; }
    try{
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      micStream = stream; usingMic = true; micBtn.textContent = 'Stop Mic';
      setupMediaStreamSource(stream);
    }catch(err){ alert('Mic access denied'); }
  });

  function stopMic(){
    if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream = null; }
    if(sourceNode && sourceNode.mediaStream){ try{ sourceNode.disconnect(); }catch(e){} }
    usingMic = false;
  }

  function setupMediaElementSource(){
    ensureAudioContext();
    if(sourceNode) try{ sourceNode.disconnect(); }catch(e){}
    sourceNode = audioCtx.createMediaElementSource(audioElement);
    sourceNode.connect(analyser);
  }
  function setupMediaStreamSource(stream){
    ensureAudioContext();
    if(sourceNode) try{ sourceNode.disconnect(); }catch(e){}
    sourceNode = audioCtx.createMediaStreamSource(stream);
    sourceNode.connect(analyser);
  }

  playBtn.addEventListener('click', async ()=>{
    ensureAudioContext();
    if(audioCtx.state === 'suspended') await audioCtx.resume();
    if(usingMic){
      if(rafId){ stopVisual(); playBtn.textContent = 'Play'; }
      else { startVisual(); playBtn.textContent = 'Pause'; }
      return;
    }
    if(!audioElement.src){ alert('Load audio or use mic'); return; }
    if(audioElement.paused){ 
      try { await audioElement.play(); }
      catch(e){console.error(e);}
      playBtn.textContent = 'Pause'; startVisual(); 
    }
    else { audioElement.pause(); playBtn.textContent = 'Play'; stopVisual(); }
  });

  volumeControl.addEventListener('input', ()=>{ if(gainNode) gainNode.gain.value = parseFloat(volumeControl.value); });

  repeatBtn.addEventListener('click', () => {
    isRepeat = !isRepeat;
    repeatBtn.textContent = `Repeat: ${isRepeat ? 'On' : 'Off'}`;
    if(audioElement){
      audioElement.loop = isRepeat;
    }
  });

  randomizeBtn.addEventListener('click', () => {
    randomLinesActive = true;
    generateRandomColors();
    generateRandomLines();
  });

  function generateRandomColor(){
    // bright colors
    const hue = Math.floor(Math.random()*360);
    return `hsl(${hue}, 80%, 60%)`;
  }
  function generateRandomColors(){
    barColorInput.value = hslToHex(Math.floor(Math.random()*360), 80, 60);
    waveColorInput.value = hslToHex(Math.floor(Math.random()*360), 80, 60);
  }

  // Convert HSL to HEX for input color value
  function hslToHex(h,s,l){
    s /= 100; l /= 100;
    let c = (1 - Math.abs(2*l - 1)) * s;
    let x = c * (1 - Math.abs((h / 60) % 2 - 1));
    let m = l - c/2;
    let r=0, g=0, b=0;
    if(h < 60){r=c;g=x;b=0;}
    else if(h < 120){r=x;g=c;b=0;}
    else if(h < 180){r=0;g=c;b=x;}
    else if(h < 240){r=0;g=x;b=c;}
    else if(h < 300){r=x;g=0;b=c;}
    else{r=c;g=0;b=x;}
    r = Math.round((r+m)*255);
    g = Math.round((g+m)*255);
    b = Math.round((b+m)*255);
    return "#" + [r,g,b].map(x=>x.toString(16).padStart(2,"0")).join('');
  }

  // Generate random lines info (startX, startY, endX, endY, color, width)
  function generateRandomLines(){
    randomLines = [];
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const lineCount = 15 + Math.floor(Math.random()*10);
    for(let i=0; i<lineCount; i++){
      randomLines.push({
        x1: Math.random()*w,
        y1: Math.random()*h,
        x2: Math.random()*w,
        y2: Math.random()*h,
        color: generateRandomColor(),
        width: 1 + Math.random()*2
      });
    }
  }

  function startVisual(){
    const barCount = Math.min(Math.max(8, parseInt(barsInput.value)||64), 256);
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    waveformArray = new Uint8Array(analyser.fftSize);
    if(rafId) cancelAnimationFrame(rafId);
    drawFrame();
  }
  function stopVisual(){ if(rafId) cancelAnimationFrame(rafId); rafId = null; randomLinesActive = false; }

  function drawFrame(){
    rafId = requestAnimationFrame(drawFrame);
    analyser.getByteFrequencyData(dataArray);
    analyser.getByteTimeDomainData(waveformArray);
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);

    const w = canvas.clientWidth, h = canvas.clientHeight;
    const barColor = hexToRGBA(barColorInput.value);
    const waveColor = hexToRGBA(waveColorInput.value);
    const barCount = Math.min(Math.max(8, parseInt(barsInput.value)||64), 256);
    const mode = modeSelect.value;

    if(randomLinesActive){
      drawRandomLines();
    }

    if(mode.includes("Bars") && !mode.includes("Circle")){
      drawBars(w,h,barCount,barColor);
    }
    if(mode.includes("Wave") && !mode.includes("Circle")){
      drawWave(w,h,waveColor);
    }
    if(mode.includes("Circle")){
      ctx.save();
      ctx.translate(w/2, h/2);
      if(mode.includes("Bars")) drawCircleBars(Math.min(w,h)/2.2,barCount,barColor);
      if(mode.includes("Wave")) drawCircleWave(Math.min(w,h)/2.5,waveColor);
      ctx.restore();
    }
  }

  function drawBars(w,h,count,color){
    const step = Math.floor(dataArray.length / count);
    const gap = Math.max(2, Math.floor(w / (count*10)));
    const barWidth = (w - (count-1)*gap) / count;
    for(let i=0;i<count;i++){
      let sum=0; for(let j=0;j<step;j++) sum += dataArray[i*step+j];
      const avg = sum/step, norm = avg/255, barHeight = Math.pow(norm,1.2) * (h*0.85);
      const x = i*(barWidth+gap), y = h - barHeight;
      ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},0.95)`;
      ctx.fillRect(x,y,barWidth,barHeight);
    }
  }
  function drawWave(w,h,color){
    ctx.lineWidth=2; ctx.beginPath(); ctx.strokeStyle=`rgba(${color.r},${color.g},${color.b},0.95)`;
    const sliceWidth = w / waveformArray.length;
    let x=0;
    for(let i=0;i<waveformArray.length;i++){
      const v = waveformArray[i]/128.0;
      const py = v*(h/2);
      if(i===0) ctx.moveTo(x,py);
      else ctx.lineTo(x,py);
      x += sliceWidth;
    }
    ctx.stroke();
  }
  function drawCircleBars(radius,count,color){
    const step = Math.floor(dataArray.length / count);
    for(let i=0;i<count;i++){
      let sum=0; for(let j=0;j<step;j++) sum += dataArray[i*step+j];
      const avg = sum/step, norm = avg/255;
      const barLen = Math.pow(norm,1.2) * (radius*0.8);
      const angle = (i/count)*Math.PI*2;
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(radius,0);
      ctx.lineTo(radius+barLen,0);
      ctx.strokeStyle = `rgba(${color.r},${color.g},${color.b},0.95)`;
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.rotate(-angle);
    }
  }
  function drawCircleWave(radius,color){
    ctx.beginPath();
    for(let i=0;i<waveformArray.length;i++){
      const v = waveformArray[i]/128.0;
      const amp = (v-1)*radius*0.3;
      const angle = (i/waveformArray.length)*Math.PI*2;
      const x = (radius+amp)*Math.cos(angle);
      const y = (radius+amp)*Math.sin(angle);
      if(i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.strokeStyle = `rgba(${color.r},${color.g},${color.b},0.95)`;
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function drawRandomLines(){
    randomLines.forEach(line=>{
      ctx.beginPath();
      ctx.strokeStyle = line.color;
      ctx.lineWidth = line.width;
      ctx.moveTo(line.x1,line.y1);
      ctx.lineTo(line.x2,line.y2);
      ctx.stroke();
    });
  }

  function hexToRGBA(hex){
    hex = hex.replace('#',''); if(hex.length===3) hex = hex.split('').map(c=>c+c).join('');
    return {r:parseInt(hex.substr(0,2),16), g:parseInt(hex.substr(2,2),16), b:parseInt(hex.substr(4,2),16)};
  }

  // Resume audio context on first user interaction
  window.addEventListener('click', async ()=>{
    if(audioCtx && audioCtx.state === 'suspended') await audioCtx.resume();
  }, {once:true});

})();
</script>
</body>
</html>
